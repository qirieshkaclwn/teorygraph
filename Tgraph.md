+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

17.09.2025

unvisited,visited,closed

**deep First search**
```
dfs(v):
    mark v as visited
    for each unvisited neighbor w:
        dfs(w)
    mark v as closed
```
**D1**: v1->v2->v3->v1  
**D2**: v4->v5->v4  
**D3**: ....

**G1**: V1-V2-V3-V1  
**G2**: .....

**Соотнесённым графом G орграфа D** называется граф, у которого множество вершин совпадает с орграфом:  
**V(G) = V(D)**,  
а множество рёбер:  
**E(G) = {{Vi,Vj} | (Vi,Vj) принадлежат E(D)}**

**Связным** называется орграф, соотнесённый граф которого связен.

**Компонентой слабой связности** орграфа D называется максимально связный подграф.

**Компонентой сильной связности** орграфа D называется такой его максимальный подграф, в котором для любых вершин Vi, Vj верно, что Vi достижима из Vj, а Vj достижима из Vi.

Две вершины называются **сильно связными**, если можно построить контур, включающий в себя эти две вершины.

Орграф называется **сильносвязным**, если состоит из одной компоненты сильной связности.

Орграф называется **слабо связным**, если является связным, но не является сильно связным.

- компонента слабой связности > 1: → орграф не связен.  
- компонента слабой связности = 1 → орграф связен.  
- компонента сильной связности > 1 → слабо связен.  
- компонента сильной связности = 1 → сильно связен.

**Конденсацией (факторграфом) D\*** орграфа D называется орграф, в котором вершинами являются S1,S2,...Sk — компоненты сильной связности орграфа D, а дуга (Si,Sj) принадлежит E(D\*), если существует дуга, соединяющая вершину из Si с вершиной из Sj.

---

**Алгоритм Косарайю**  
(рисунок)

1. Строим дерево разбора (запускаем поиск в глубину, нумеруя вершины в порядке выходящих).  
2. Инвертируем орграф (меняем направление всех дуг).  
3. Запускаем поиск в глубину, начиная с вершины с наибольшим номером.  
4. Получившиеся деревья определяют компоненты сильной связности.

---

**Точкой Сочленения (шарниром, cut vertex)** называется вершина, при удалении которой в нём увеличивается число компонент связности.

**Мостом (Bridge, cut edge)** — ребро, при удалении которого в нём увеличивается число компонент связности.

**Неразделимым графом** называется граф, не имеющий точек сочленения.

**Блок (компонент двусвязности)** — максимальный неразделимый подграф.

**Граф блоков G\*** — граф, в котором вершинами являются блоки графа G, а ребро {Bi,Bj} есть, если связаны вершины Bi и Bj.

---

**Взвешенный граф** — граф, в котором каждому ребру сопоставлено число, называемое весом этого ребра.

**Расстоянием между вершинами графа** называется сумма весов рёбер кратчайшей простой цепи, связывающей их (такая цепь называется геодезической).

Расстояние между вершинами является метрикой и обладает следующими свойствами:

1. Расстояние от точки до себя = 0.  
2. Расстояние от точки Vi до Vj = от Vj до Vi.  
3. Расстояние от Vi до Vj ≤ от Vi до Vk + от Vk до Vj.

**Эксцентриситетом вершины** называется наибольшее расстояние из расстояний до любой другой вершины в графе.

**Диаметр графа** — максимальный из всех эксцентриситетов вершин.  
**Радиус графа** — минимальный из всех эксцентриситетов вершин.

Вершины, у которых эксцентриситет = диаметру — **периферийные**.  
Вершины, у которых эксцентриситет = радиусу — **центральные**.

---

**Алгоритмы поиска кратчайших расстояний**

1. **От 1 ко всем**:  
   - Дейкстра  
   - Беллман-Форд-Мур

2. **От всех ко всем**:  
   - Флойда-Уоршелла  
   - Джонсона

---

**Дейкстра**

0. Сопоставляем каждой вершине метку расстояния от начальной и метку предыдущей вершины.  
   У начальной инициализируем как (0, -1).  
   У остальных — (∞, -1).  

1. Выбрать вершину с наименьшей меткой расстояния от начальной.  
2. Просчитываем расстояния до всех не закрытых соседей; если значение меньше — переписываем метку расстояния и метку предыдущей вершины.  
3. Помечаем текущую вершину как закрытую.  
4. Если есть незакрытые вершины — переходим к шагу 1.

---

**Алгоритм Флойда-Уоршелла**

0. Матрица расстояний, где:  
   d(Vi,Vj) =  
   - 0, если Vi = Vj  
   - w(Vi,Vj), если {Vi,Vj} ∈ E  
   - ∞, если {Vi,Vj} ∉ E  

1. Для каждой k-ой вершины проверяем: есть ли путь из i в j короче через k.  
   D[i][j] = min(D[i][j], D[i][k] + D[k][j])
